### RDB/AOF

#### RDB
* 将某个点上的数据库状态保存到一个RDB文件中
* SAVE: 阻塞Redis服务器进程，直到RDB文件创建完成
* BGSAVE: 派生出一个子进程进行保存，所以该命令不会阻塞服务器
   * Fork新进程时，虽然可共享的数据内容不需要复制
   * 但会复制之前进程空间的内存页表，这个复制是主线程来做的，会阻塞所有的读写操作，并且随着内存使用量越大耗时越长
* 载入RDB文件期间，会一直处于阻塞状态
* save选项，可以每隔一段时间自动执行一次BGSAVE命令
   * save 900 1
   * 在900s内，对数据库进行了至少一次修改
* RDB文件是一个经过压缩的二进制文件，由多个部分组成
* 对于不同类型的键值对，RDB文件会使用不同的方式来保存它们

#### AOF
* AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。
* AOF文件中的所有命令都以Redis命令请求协议的格式保存。
* 命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件。
* appendfsync选项的不同值对AOF持久化功能的安全性以及Redis服务器的性能
有很大的影响。
   * always： 每个事件循环都要讲aof_buf缓冲区的所有内容写入并同步到AOF文件
   * everysec： 将aof_buf写入到AOF文件，如果上次同步时间时间距离超过一秒钟，则对AOF再次同步
   * no: 将aof_buf写入到AOF，但由操作系统决定同步
   * 写入和同步的区别：将一些数据写入到文件的时候， 操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后， 才真正地将缓冲区中的数据写入到磁盘里面。
* 服务器只要载入并重新执行保存在AOF文件中的命令， 就可以还原数据库本来的状态。
* AOF重写可以产生一个新的AOF文件， 这个新的AOF文件和原有的AOF文件所
保存的数据库状态一样， 但体积更小。
* AOF重写是一个有歧义的名字， 该功能是通过读取数据库中的键值对来实现的， 程
序无须对现有AOF文件进行任何读入、分析或者写入操作。
* 在执行BGREWRITEAOF命令时， Redis服务器会维护一个AOF重写缓冲区， 该缓
冲区会在子进程创建新AOF文件期间， 记录服务器执行的所有写命令。当子进程完
成创建新AOF文件的工作之后， 服务器会将重写缓冲区中的所有内容追加到新AOF
文件的末尾， 使得新旧两个AOF文件所保存的数据库状态一致。最后， 服务器用新
的AOF文件替换旧的AOF文件， 以此来完成AOF文件重写操作。



#### RDB/AOF详解
* [RDB/AOF详解](https://segmentfault.com/a/1190000012908434?utm_source=tag-newest)
* [RDB/AOF区别](https://blog.csdn.net/sinat_35821285/article/details/79842188)
* [redis数据迁移](https://www.cnblogs.com/hygs/p/6826202.html)